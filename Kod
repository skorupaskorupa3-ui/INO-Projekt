#include <iostream> // wejscie / wyjscie
#include <conio.h> // biblioteka do obslugi klawiatury 
#include <windows.h> // biblioteka systemowa windows 
#include <ctime> // do losowania pozycji owocow


using namespace std;

//zmienne globalne 
bool koniec_gry; // stan gry - true oznacza koniec
const int szerokosc = 20; // stala szerokosc planszy 
const int wysokosc = 20; // stala wysokosc planszy
int x, y; // wspolrzedne (x,y) glowy weza
int wsp_owocu_X, wsp_owocu_Y; // wspolrzedne (x,y) owocu
int wynik; // aktualny wynik gracza


// typ wyliczeniowy dla kierunkow ruchu
enum eDirecton { STOP = 0, LEWO, PRAWO, GORA, DOL }; // typ wyliczeniowy dla kierunkow
eDirecton kierunek; // aktualny kierunek ruchu weza

void ustawienia()
{
    koniec_gry = false; // inicjalizacja stanu gry
    kierunek = STOP; // poczatkowy kierunek na stop
    x = szerokosc / 2; // umieszczenie glowy x na srodku
    y = wysokosc / 2; // umieszczenie glowy y na srodku
    wsp_owocu_X = rand() % szerokosc; // losowanie pozycji x owocu
    wsp_owocu_Y = rand() % wysokosc; // losowanie pozycji y owocu
    wynik = 0; // zerowanie wyniku (na poczatku gry)
}

void plansza()
{
    system("cls"); // czyszczenie ekranu konsoli


    for (int i = 0; i < szerokosc + 2; i++) // tworzenie sufitu
        cout << "#";
    cout << endl;


    for (int i = 0; i < wysokosc; i++) // kreowanie scian
    {

        for (int j = 0; j < szerokosc; j++)
        {
            if (j == 0)
                cout << "#"; // lewa sciana

            if (i == y && j == x)
                cout << "O";    // symbol "O" to glowa weza 
            else if (i == wsp_owocu_Y && j == wsp_owocu_X)
                cout << "F";    // symbol "F" to owoce do zbierania
            else
            {
                
                cout << " "; // jesli nic nie narysowano, zostaw puste pole
            }

            if (j == szerokosc - 1)
                cout << "#"; // prawa sciana
        }
        cout << endl;
    }

    for (int i = 0; i < szerokosc + 2; i++) // tworzenie podlogi
        cout << "#";
    cout << endl;

    cout << "wynik:" << wynik << endl; // licznik punktow
}

void sterowanie()
{
    if (_kbhit()) // sprawdzenie, czy klawisz zostal nacisniety (biblioteka conio.h)
    {
        switch (_getch()) // sterowanie weza (awsd)
        {
        case 'a':
            kierunek = LEWO;
            break;
        case 'd':
            kierunek = PRAWO;
            break;
        case 'w':
            kierunek = GORA;
            break;
        case 's':
            kierunek = DOL;
            break;
        case 'x':
            koniec_gry = true; // wyjscie z gry za pomoca klawisza x
            break;
        }
    }
}

void mechanika_gry()
{
    

    switch (kierunek) // aktualizacja wspolrzednych na podstawie kierunku wybranego przez uzytkownika
    {
    case LEWO:
        x--;
        break;
    case PRAWO:
        x++;
        break;
    case GORA:
        y--;
        break;
    case DOL:
        y++;
        break;
    default:
        break;
    }

    // teleportacja przez sciany (poziomo / pionowo)
    if (x >= szerokosc) x = 0; // wejscie w prawa krawedz -> teleportacja na lewa strone
    else if (x < 0) x = szerokosc - 1; // wejscie w lewa krawedz -> teleporatcja na prawa strone
    if (y >= wysokosc) y = 0; // wejscie w dolna krawdz -> teleportacja u gory
    else if (y < 0) y = wysokosc - 1; // wejscie w gorna krawdz -> teleportacja do dolu

    

    // zbieranie punktow
    if (x == wsp_owocu_X && y == wsp_owocu_Y)
    {
        wynik += 10; // wybrano wartosc 10 za jeden owoc
        wsp_owocu_X = rand() % szerokosc; // losowanie wspolrzednej x
        wsp_owocu_Y = rand() % wysokosc; // losowanie wspolrzednej y
        
    }
}

int main()
{
    srand(time(0)); // inicjalizacja losowosci za pomoca aktualnego czasu
    ustawienia(); // ustawienie poczatkowego stanu gry

    while (!koniec_gry) // glowna petla gry
    {
        plansza(); // wywolanie funkcji tworzaca plansze 
        sterowanie(); // obsluga wejscia gracza (sterowanie)
        mechanika_gry(); // przetwarzanie logiki (ruch, kolizje)
        Sleep(50); // opoznienie 50 milisekund (kontroluje to predkosc gry)
    }

    return 0;
}
